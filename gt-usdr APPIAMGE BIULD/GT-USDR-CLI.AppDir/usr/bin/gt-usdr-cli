#!/bin/bash

APP_NAME="GT-USDR"
VERSION="1.0"
AUTHOR="GNUTUX"

LANGUAGE="ar"

choose_language() {
    clear
    show_logo
    echo "Select language / ÿßÿÆÿ™ÿ± ÿßŸÑŸÑÿ∫ÿ©:"
    echo "1) English"
    echo "2) ÿßŸÑÿπÿ±ÿ®Ÿäÿ©"
    read -p "> " lang_choice
    case $lang_choice in
        1) LANGUAGE="en";;
        2) LANGUAGE="ar";;
        *) LANGUAGE="ar";;
    esac
}

t() {
    case $LANGUAGE in
        ar)
            case $1 in
                WELCOME) echo "ŸÖÿ±ÿ≠ÿ®Ÿãÿß ÿ®ŸÉ ŸÅŸä $APP_NAME $VERSION";;
                INTRO) echo "üß© ÿ£ÿØÿßÿ© ŸÖÿ™ŸÇÿØŸÖÿ© ŸÑŸÅÿ≠ÿµÿå ÿ•ÿµŸÑÿßÿ≠ÿå ÿ™ŸáŸäÿ¶ÿ©ÿå Ÿàÿ•ŸÜŸÇÿßÿ∞ ŸÖŸÅÿßÿ™Ÿäÿ≠ Ÿàÿ®ÿ∑ÿßŸÇÿßÿ™ ÿßŸÑÿ∞ÿßŸÉÿ±ÿ© ÿßŸÑÿÆÿßÿ±ÿ¨Ÿäÿ© (USB/SD)";;
                SELECT_DISK) echo "üîå ÿßÿÆÿ™ÿ± ÿ±ŸÇŸÖ ÿßŸÑÿ¨Ÿáÿßÿ≤ ÿßŸÑÿÆÿßÿ±ÿ¨Ÿä (ÿ£Ÿà 0 ŸÑŸÑÿÆÿ±Ÿàÿ¨):";;
                SELECT_TARGET) echo "ÿßÿÆÿ™ÿ± ÿßŸÑŸÇÿ≥ŸÖ ÿ£Ÿà ÿßŸÑÿ¨Ÿáÿßÿ≤ ÿ®ÿßŸÑŸÉÿßŸÖŸÑ:";;
                INVALID_CHOICE) echo "‚ùé ÿÆŸäÿßÿ± ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠";;
                MAIN_MENU) echo "üìã ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©";;
                DEVICE_INFO) echo "üîé ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ¨Ÿáÿßÿ≤/ÿßŸÑŸÇÿ≥ŸÖ";;
                CHECK) echo "ü©∫ ŸÅÿ≠ÿµ";;
                REPAIR) echo "üõ†Ô∏è ÿ•ÿµŸÑÿßÿ≠";;
                BADBLOCKS) echo "üöß ŸÅÿ≠ÿµ ÿßŸÑŸÇÿ∑ÿßÿπÿßÿ™ ÿßŸÑÿ™ÿßŸÑŸÅÿ©";;
                SMART) echo "üí° ŸÅÿ≠ÿµ ÿßŸÑÿµÿ≠ÿ© (SMART)";;
                BACKUP) echo "üíæ ŸÜÿ≥ÿÆ ÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿä";;
                FORMAT) echo "üßπ ÿ™ŸáŸäÿ¶ÿ©";;
                EXIT_MENU) echo "üîô ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑÿ¨Ÿáÿßÿ≤/ÿßŸÑŸÇÿ≥ŸÖ";;
                QUIT) echo "üö™ ÿÆÿ±Ÿàÿ¨";;
                SUCC) echo "‚úÖ ÿ™ŸÖÿ™ ÿßŸÑÿπŸÖŸÑŸäÿ© ÿ®ŸÜÿ¨ÿßÿ≠!";;
                MISSING_DEP) echo "‚ùó ÿßŸÑÿ£ÿØÿßÿ© ÿ£Ÿà ÿßŸÑÿ≠ÿ≤ŸÖÿ© ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ© ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ±ÿ©: $2
‚û°Ô∏è ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ™ÿ´ÿ®Ÿäÿ™ ÿßŸÑÿ≠ÿ≤ŸÖÿ©: $3
"; t ENTER_TO_CONTINUE;;
                PRESS_ENTER) read -p "‚Ü©Ô∏è ÿßÿ∂ÿ∫ÿ∑ Enter ŸÑŸÑŸÖÿ™ÿßÿ®ÿπÿ©...";;
                NO_DEVICE) echo "‚ùå ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ£ÿ¨Ÿáÿ≤ÿ© ÿÆÿßÿ±ÿ¨Ÿäÿ© ŸÖÿ™ÿµŸÑÿ©!";;
                NO_PARTS) echo "‚ùå ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ£ŸÇÿ≥ÿßŸÖ ŸÖÿ™ÿßÿ≠ÿ©!";;
                EXIT_THANKS) echo "ÿ¥ŸÉÿ±ÿßŸã ŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ $APP_NAME!";;
                CHOOSE_FS) echo "ÿßÿÆÿ™ÿ± ŸÜÿ∏ÿßŸÖ ÿßŸÑŸÖŸÑŸÅÿßÿ™:" && echo "1) FAT32" && echo "2) exFAT" && echo "3) NTFS" && echo "4) ext4";;
                CONFIRM_FORMAT) read -p "ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÑÿ™ŸáŸäÿ¶ÿ©ÿü (y/N): " confirm;;
                BACK) echo "üîô ÿπŸàÿØÿ©";;
                CHOOSE_DEVTYPE) echo "ÿßÿÆÿ™ÿ± ŸÜŸàÿπ ÿßŸÑÿ¨Ÿáÿßÿ≤:";;
                SMART_MENU) echo "ÿÆŸäÿßÿ±ÿßÿ™ ÿßŸÑÿµÿ≠ÿ© (SMART):";;
                SMART_INFO) echo "ÿπÿ±ÿ∂ ŸÖÿπŸÑŸàŸÖÿßÿ™ SMART";;
                SMART_SHORT) echo "ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßÿÆÿ™ÿ®ÿßÿ± ŸÇÿµŸäÿ±";;
                SMART_LONG) echo "ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßÿÆÿ™ÿ®ÿßÿ± ÿ∑ŸàŸäŸÑ";;
                SMART_LOG) echo "ÿπÿ±ÿ∂ ÿ≥ÿ¨ŸÑ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±ÿßÿ™";;
                SMART_CUSTOM_TYPE) echo "ÿÆŸäÿßÿ±ÿßÿ™ ŸÜŸàÿπ ÿßŸÑÿ¨Ÿáÿßÿ≤";;
                WHOLE_DEVICE) echo "ÿßŸÑÿ¨Ÿáÿßÿ≤ ÿ®ÿßŸÑŸÉÿßŸÖŸÑ";;
                NO_PART_OR_WHOLE) echo "‚ùå ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ£ŸÇÿ≥ÿßŸÖ ŸÖÿ™ÿßÿ≠ÿ© ÿπŸÑŸâ ÿßŸÑÿ¨Ÿáÿßÿ≤ ÿßŸÑŸÖÿ≠ÿØÿØ!";;
                *) echo "$1";;
            esac
            ;;
        en|*)
            case $1 in
                WELCOME) echo "Welcome to $APP_NAME $VERSION";;
                INTRO) echo "üß© Advanced tool for checking, repairing, formatting, and rescuing USB/SD storage devices";;
                SELECT_DISK) echo "üîå Enter the external device number (or 0 to exit):";;
                SELECT_TARGET) echo "Choose partition or whole device:";;
                INVALID_CHOICE) echo "‚ùé Invalid choice";;
                MAIN_MENU) echo "üìã Main Menu";;
                DEVICE_INFO) echo "üîé Device/Partition Information";;
                CHECK) echo "ü©∫ Check";;
                REPAIR) echo "üõ†Ô∏è Repair";;
                BADBLOCKS) echo "üöß Badblocks Scan";;
                SMART) echo "üí° Health check (SMART)";;
                BACKUP) echo "üíæ Backup";;
                FORMAT) echo "üßπ Format";;
                EXIT_MENU) echo "üîô Change Device/Partition";;
                QUIT) echo "üö™ Exit";;
                SUCC) echo "‚úÖ Operation completed successfully!";;
                MISSING_DEP) echo "‚ùó Required tool or package is missing: $2
‚û°Ô∏è Please install the package: $3
"; t ENTER_TO_CONTINUE;;
                PRESS_ENTER) read -p "‚Ü©Ô∏è Press Enter to continue...";;
                NO_DEVICE) echo "‚ùå No external devices connected!";;
                NO_PARTS) echo "‚ùå No partitions available!";;
                EXIT_THANKS) echo "Thank you for using $APP_NAME!";;
                CHOOSE_FS) echo "Choose file system type:" && echo "1) FAT32" && echo "2) exFAT" && echo "3) NTFS" && echo "4) ext4";;
                CONFIRM_FORMAT) read -p "Are you sure you want to format? (y/N): " confirm;;
                BACK) echo "üîô Back";;
                CHOOSE_DEVTYPE) echo "Choose device type:";;
                SMART_MENU) echo "SMART Health Options:";;
                SMART_INFO) echo "Show SMART info";;
                SMART_SHORT) echo "Run short test";;
                SMART_LONG) echo "Run long test";;
                SMART_LOG) echo "Show SMART test log";;
                SMART_CUSTOM_TYPE) echo "Device type options";;
                WHOLE_DEVICE) echo "Whole Device";;
                NO_PART_OR_WHOLE) echo "‚ùå No partitions available on selected device!";;
                *) echo "$1";;
            esac
            ;;
    esac
}

check_dep() {
    if ! command -v "$1" &>/dev/null; then
        t MISSING_DEP "$1" "$2"
        return 1
    fi
    return 0
}

show_logo() {
    echo -e "\e[32m"
    echo "________________   _____  ________________________ "
    echo "__  ____/__  __/   __  / / /_  ___/__  __ \\__  __ \\"
    echo "_  / __ __  /_______  / / /_____ \\__  / / /_  /_/ /"
    echo "/ /_/ / _  /_/_____/ /_/ / ____/ /_  /_/ /_  _, _/ "
    echo "\\____/  /_/        \\____/  /____/ /_____/ /_/ |_|  "
    echo "                                                   "
    echo -e "   üöÄ $APP_NAME $VERSION by $AUTHOR"
    t INTRO
    echo
}

list_external_disks() {
    # Ÿäÿπÿ±ÿ∂ ŸÅŸÇÿ∑ ÿßŸÑÿ£ŸÇÿ±ÿßÿµ ÿßŸÑÿÆÿßÿ±ÿ¨Ÿäÿ© ŸÖŸÜ ŸÜŸàÿπ disk (usb/mmc)
    lsblk -ndo NAME,TYPE,SIZE,TRAN | awk '$2=="disk" && ($4=="usb" || $4=="mmc") {printf "/dev/%s [%s]\n", $1, $3}'
}

list_partitions_of_disk() {
    local disk="$1"
    # Ÿäÿπÿ±ÿ∂ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ£ŸÇÿ≥ÿßŸÖ ÿßŸÑÿ™ÿßÿ®ÿπÿ© ŸÑŸÑŸÇÿ±ÿµ ÿßŸÑŸÖÿ≠ÿØÿØ
    lsblk -lno NAME,SIZE,FSTYPE,LABEL,TYPE "$disk" | awk '$5=="part" { printf "/dev/%s (%s, %s, %s)\n", $1, $2, $3, $4 }'
}

choose_disk_and_target() {
    while true; do
        clear
        show_logo
        mapfile -t DISKS < <(list_external_disks)
        [ ${#DISKS[@]} -eq 0 ] && t NO_DEVICE && t PRESS_ENTER && exit 1
        echo "== $(t SELECT_DISK) =="
        for idx in "${!DISKS[@]}"; do
            echo "$((idx+1)). ${DISKS[$idx]}"
        done
        echo "0. $(t QUIT)"
        t SELECT_DISK
        read -p "> " disknum
        if [[ "$disknum" == "0" ]]; then
            clear; show_logo; t EXIT_THANKS; exit 0
        elif [[ "$disknum" =~ ^[0-9]+$ ]] && (( disknum >= 1 && disknum <= ${#DISKS[@]} )); then
            DISKDEV=$(echo "${DISKS[$((disknum-1))]}" | awk '{print $1}')
            break
        else
            t INVALID_CHOICE; t PRESS_ENTER
        fi
    done

    # ÿ¨ŸÑÿ® ÿßŸÑÿ£ŸÇÿ≥ÿßŸÖ ÿßŸÑÿ™ÿßÿ®ÿπÿ© ŸÑŸÑŸÇÿ±ÿµ ÿßŸÑŸÖÿÆÿ™ÿßÿ±
    while true; do
        clear
        show_logo
        mapfile -t PARTS < <(list_partitions_of_disk "$DISKDEV")
        TARGETS=()
        TARGETS+=("$DISKDEV ($(t WHOLE_DEVICE))")
        for p in "${PARTS[@]}"; do
            TARGETS+=("$p")
        done
        if [ ${#TARGETS[@]} -eq 0 ]; then
            t NO_PART_OR_WHOLE; t PRESS_ENTER
            return 1
        fi
        echo "== $(t SELECT_TARGET) =="
        for idx in "${!TARGETS[@]}"; do
            echo "$((idx+1)). ${TARGETS[$idx]}"
        done
        echo "0. $(t BACK)"
        read -p "> " targetnum
        if [[ "$targetnum" == "0" ]]; then
            return 1
        elif [[ "$targetnum" =~ ^[0-9]+$ ]] && (( targetnum >= 1 && targetnum <= ${#TARGETS[@]} )); then
            TARGETDEV=$(echo "${TARGETS[$((targetnum-1))]}" | awk '{print $1}')
            return 0
        else
            t INVALID_CHOICE; t PRESS_ENTER
        fi
    done
}

show_device_info() {
    check_dep lsblk util-linux || return
    check_dep blkid util-linux || return
    lsblk -f "$TARGETDEV"
    blkid "$TARGETDEV"
    t PRESS_ENTER
}

check_device() {
    check_dep fsck util-linux || return
    sudo fsck -n "$TARGETDEV"
    t PRESS_ENTER
}

repair_device() {
    check_dep fsck util-linux || return
    sudo fsck -y "$TARGETDEV"
    t PRESS_ENTER
}

badblocks_scan() {
    check_dep badblocks e2fsprogs || return
    sudo badblocks -v "$TARGETDEV"
    t PRESS_ENTER
}

smart_menu() {
    check_dep smartctl smartmontools || return
    while true; do
        clear
        show_logo
        echo "=== $(t SMART_MENU) ==="
        echo "1) $(t SMART_INFO)"
        echo "2) $(t SMART_SHORT)"
        echo "3) $(t SMART_LONG)"
        echo "4) $(t SMART_LOG)"
        echo "5) $(t SMART_CUSTOM_TYPE)"
        echo "0) $(t BACK)"
        read -p "> " smart_opt
        case $smart_opt in
            1) sudo smartctl -a "$TARGETDEV";;
            2) sudo smartctl -t short "$TARGETDEV"; echo "Short test started. Run option 4 to see results.";;
            3) sudo smartctl -t long "$TARGETDEV"; echo "Long test started. Run option 4 to see results.";;
            4) sudo smartctl -l selftest "$TARGETDEV";;
            5)
                t CHOOSE_DEVTYPE
                PS3="$(t CHOOSE_DEVTYPE) #: "
                select devtype in "sat" "scsi" "usbjmicron" "usbcypress" "test" "$(t BACK)"; do
                    case $devtype in
                        sat|scsi|usbjmicron|usbcypress|test)
                            echo "Selected: $devtype"
                            sudo smartctl -d "$devtype" -a "$TARGETDEV"
                            break
                            ;;
                        "$(t BACK)") break ;;
                        *) t INVALID_CHOICE;;
                    esac
                done
                ;;
            0) break;;
            *) t INVALID_CHOICE; t PRESS_ENTER ;;
        esac
        t PRESS_ENTER
    done
}

backup_device() {
    check_dep dd coreutils || return
    backupfile=~/backup-$(basename "$TARGETDEV")-$(date +%Y%m%d%H%M%S).img
    sudo dd if="$TARGETDEV" of="$backupfile" bs=4M status=progress
    echo "Backup saved to: $backupfile"
    t PRESS_ENTER
}

format_device() {
    t CHOOSE_FS
    read -p "> " fs_choice
    case $fs_choice in
        1) FS_TYPE="vfat";;
        2) FS_TYPE="exfat";;
        3) FS_TYPE="ntfs";;
        4) FS_TYPE="ext4";;
        *) t INVALID_CHOICE; return;;
    esac
    t CONFIRM_FORMAT
    [[ "$confirm" != "y" && "$confirm" != "Y" ]] && return
    sudo umount "$TARGETDEV" 2>/dev/null
    case $FS_TYPE in
        vfat)
            check_dep mkfs.vfat dosfstools || return
            sudo mkfs.vfat -F 32 "$TARGETDEV"
            ;;
        exfat)
            check_dep mkfs.exfat exfatprogs || return
            sudo mkfs.exfat "$TARGETDEV"
            ;;
        ntfs)
            check_dep mkfs.ntfs ntfs-3g || return
            sudo mkfs.ntfs -f "$TARGETDEV"
            ;;
        ext4)
            check_dep mkfs.ext4 e2fsprogs || return
            sudo mkfs.ext4 "$TARGETDEV"
            ;;
    esac
    t SUCC
    t PRESS_ENTER
}

main_menu() {
    while true; do
        if ! choose_disk_and_target; then continue; fi
        while true; do
            clear
            show_logo
            echo -e "\e[44;97m$(t MAIN_MENU)\e[0m"
            echo "1. $(t DEVICE_INFO)"
            echo "2. $(t CHECK)"
            echo "3. $(t REPAIR)"
            echo "4. $(t BADBLOCKS)"
            echo "5. $(t SMART)"
            echo "6. $(t BACKUP)"
            echo "7. $(t FORMAT)"
            echo "8. $(t EXIT_MENU)"
            echo "0. $(t QUIT)"
            read -p "> " opt
            case $opt in
                1) show_device_info ;;
                2) check_device ;;
                3) repair_device ;;
                4) badblocks_scan ;;
                5) smart_menu ;;
                6) backup_device ;;
                7) format_device ;;
                8) break ;;
                0) clear; show_logo; t EXIT_THANKS; exit 0 ;;
                *) t INVALID_CHOICE; t PRESS_ENTER ;;
            esac
        done
    done
}

choose_language
main_menu
